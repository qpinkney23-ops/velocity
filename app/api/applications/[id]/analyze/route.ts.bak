import { NextResponse } from "next/server";

// Helper to load pdf-parse in a way that works whether the module is CJS or ESM
async function loadPdfParse(): Promise<(data: Buffer) => Promise<any>> {
  const mod: any = await import("pdf-parse");
  return (mod?.default ?? mod) as (data: Buffer) => Promise<any>;
}

type AnalyzeRequest = {
  downloadURL?: string;
  docName?: string;
};

type Priority = "High" | "Medium" | "Low";

type Condition = {
  title: string;
  rationale: string;
  priority: Priority;
};

type Extracted = {
  borrowerName?: string;
  borrowerEmail?: string;

  coBorrowerName?: string;
  coBorrowerEmail?: string;

  employer?: string;
  jobTitle?: string;
  incomeAnnual?: number;

  coEmployer?: string;
  coJobTitle?: string;
  coIncomeAnnual?: number;

  creditScore?: number;
  dti?: number; // 0-1
};

function clamp(n: number, min: number, max: number) {
  return Math.max(min, Math.min(max, n));
}

function normSpaces(s: string) {
  return (s || "")
    .replace(/\r/g, "\n")
    .replace(/[ \t]+/g, " ")
    .replace(/\n{3,}/g, "\n\n")
    .trim();
}

function firstEmail(text: string): string | undefined {
  const m = text.match(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/i);
  return m?.[0];
}

function allEmails(text: string): string[] {
  const matches = text.match(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/gi) || [];
  // unique, preserve order
  const seen = new Set<string>();
  const out: string[] = [];
  for (const e of matches) {
    const k = e.toLowerCase();
    if (!seen.has(k)) {
      seen.add(k);
      out.push(e);
    }
  }
  return out;
}

function parseMoneyToken(raw: string): number | undefined {
  if (!raw) return undefined;
  let s = raw.toString().trim().toLowerCase();

  // remove $ and commas
  s = s.replace(/\$/g, "").replace(/,/g, "").trim();

  // handle 150k, 132k, 150.5k
  const km = s.match(/^(\d+(?:\.\d+)?)\s*k$/i);
  if (km) {
    const v = Number(km[1]);
    if (!Number.isFinite(v)) return undefined;
    return Math.round(v * 1000);
  }

  // handle plain number
  const v = Number(s);
  if (!Number.isFinite(v)) return undefined;
  return Math.round(v);
}

function findLabeledValue(text: string, labelRe: RegExp): string | undefined {
  // Find "Label: value" within same line-ish
  const lines = text.split("\n").map((l) => l.trim()).filter(Boolean);
  for (const line of lines) {
    const m = line.match(labelRe);
    if (m && m[1]) return m[1].trim();
  }
  return undefined;
}

function pickBestNameCandidate(s: string): string | undefined {
  const v = (s || "").trim();
  if (!v) return undefined;
  // strip trailing junk
  const cleaned = v.replace(/\s{2,}/g, " ").replace(/[|•]+/g, " ").trim();
  // avoid lines that look like addresses or long paragraphs
  if (cleaned.length > 60) return undefined;
  // avoid if mostly digits
  const digits = (cleaned.match(/\d/g) || []).length;
  if (digits >= 6) return undefined;
  return cleaned;
}

function extractCreditScore(text: string): number | undefined {
  const m =
    text.match(/(?:credit\s*score|fico)\s*[:\-]?\s*([3-8]\d{2})/i) ||
    text.match(/\b([3-8]\d{2})\b\s*(?:fico|credit\s*score)/i);
  if (!m) return undefined;
  const v = Number(m[1]);
  if (!Number.isFinite(v)) return undefined;
  return clamp(v, 300, 850);
}

function extractDTI(text: string): number | undefined {
  const m =
    text.match(/\bDTI\b\s*[:\-]?\s*([0-9]{1,2}(?:\.[0-9]{1,2})?)\s*%/i) ||
    text.match(/\bDebt\s*to\s*Income\b.*?([0-9]{1,2}(?:\.[0-9]{1,2})?)\s*%/i);
  if (!m) return undefined;
  const pct = Number(m[1]);
  if (!Number.isFinite(pct)) return undefined;
  return clamp(pct / 100, 0, 1);
}

function extractIncomeNearKeywords(text: string, who: "borrower" | "co"): number | undefined {
  // Look for income/salary lines with amounts
  const lines = text.split("\n").map((l) => l.trim()).filter(Boolean);
  const kw = who === "co" ? /(co[-\s]?borrower|co[-\s]?applicant|co[-\s]?buyer)/i : /(borrower|applicant|buyer)/i;

  // pass 1: find labeled income lines
  for (const line of lines) {
    if (!/income|salary|annual|wages|base/i.test(line)) continue;
    if (who === "co" && !kw.test(line) && /borrower|applicant/i.test(line)) {
      // If it mentions borrower/applicant but not co, keep looking
    }
    const amt =
      line.match(/\$?\s*([0-9]{2,3}(?:,[0-9]{3})+)\b/i) ||
      line.match(/\$?\s*([0-9]{2,3})\s*k\b/i) ||
      line.match(/\$?\s*([0-9]{4,6})\b/i);
    if (amt?.[1]) {
      const v = parseMoneyToken(amt[1]);
      if (typeof v === "number" && v >= 10000 && v <= 1000000) return v;
    }
  }

  // pass 2: fallback — take the largest reasonable money amount as "income-ish"
  const money = text.match(/\$?\s*([0-9]{2,3}(?:,[0-9]{3})+)\b/gi) || [];
  let best: number | undefined;
  for (const token of money) {
    const m = token.match(/([0-9]{2,3}(?:,[0-9]{3})+)/);
    const v = m?.[1] ? parseMoneyToken(m[1]) : undefined;
    if (typeof v === "number" && v >= 15000 && v <= 600000) {
      if (!best || v > best) best = v;
    }
  }
  return best;
}

function buildConditions(ex: Extracted): Condition[] {
  const out: Condition[] = [];

  if (!ex.borrowerName) out.push({ title: "Confirm borrower full legal name", rationale: "Name not confidently extracted from document.", priority: "High" });
  if (!ex.borrowerEmail) out.push({ title: "Confirm borrower email", rationale: "Email not found in document.", priority: "Medium" });

  if (!ex.incomeAnnual) out.push({ title: "Provide income documentation (pay stubs / W-2)", rationale: "Qualifying income not extracted with confidence.", priority: "High" });
  if (!ex.employer) out.push({ title: "Verification of Employment (VOE)", rationale: "Employer not extracted; confirm current employer.", priority: "High" });
  if (!ex.jobTitle) out.push({ title: "Confirm job title / position", rationale: "Job title not extracted; helpful for VOE.", priority: "Medium" });

  if (!ex.creditScore) out.push({ title: "Pull credit report (score + liabilities)", rationale: "Credit score not present in the document.", priority: "High" });

  // co-borrower conditions only if co-borrower appears at all
  if (ex.coBorrowerName || ex.coBorrowerEmail || ex.coIncomeAnnual || ex.coEmployer || ex.coJobTitle) {
    if (!ex.coBorrowerName) out.push({ title: "Confirm co-borrower legal name", rationale: "Co-borrower referenced but name not extracted.", priority: "High" });
    if (!ex.coIncomeAnnual) out.push({ title: "Provide co-borrower income docs", rationale: "Co-borrower income not extracted with confidence.", priority: "High" });
    if (!ex.coEmployer) out.push({ title: "Co-borrower VOE", rationale: "Co-borrower employer not extracted.", priority: "High" });
  }

  return out.slice(0, 10);
}

export async function POST(req: Request) {
  try {
    const body = (await req.json().catch(() => ({}))) as AnalyzeRequest;

    if (!body.downloadURL) {
      return NextResponse.json({ ok: false, error: "Missing downloadURL in request body" }, { status: 400 });
    }

    // Fetch the PDF bytes from Firebase Storage URL
    const res = await fetch(body.downloadURL);
    if (!res.ok) {
      return NextResponse.json(
        { ok: false, error: `Failed to fetch PDF: ${res.status} ${res.statusText}` },
        { status: 400 }
      );
    }

    const arrayBuffer = await res.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    const pdfParse = await loadPdfParse();
    const parsed = await pdfParse(buffer);

    const rawText = (parsed?.text ?? "").toString();
    const text = normSpaces(rawText);

    const preview = text.trim().slice(0, 1400);
    const summary =
      text.trim().length === 0
        ? "No text extracted from PDF (it may be scanned)."
        : text.trim().slice(0, 700);

    // ===== Rule-based extraction (v1) =====
    const extracted: Extracted = {};

    // emails (first = borrower, second = co if present)
    const emails = allEmails(text);
    if (emails[0]) extracted.borrowerEmail = emails[0].toLowerCase();
    if (emails[1]) extracted.coBorrowerEmail = emails[1].toLowerCase();

    // borrower/co-borrower names (label-based)
    const borrowerName =
      findLabeledValue(text, /(?:borrower|applicant|buyer)\s*(?:name)?\s*[:\-]\s*(.+)$/i) ||
      findLabeledValue(text, /(?:name)\s*[:\-]\s*(.+)$/i);

    const coName =
      findLabeledValue(text, /(?:co[-\s]?borrower|co[-\s]?applicant|co[-\s]?buyer)\s*(?:name)?\s*[:\-]\s*(.+)$/i) ||
      findLabeledValue(text, /(?:co[-\s]?applicant|co[-\s]?borrower)\s*[:\-]\s*(.+)$/i);

    extracted.borrowerName = pickBestNameCandidate(borrowerName || "") || undefined;
    extracted.coBorrowerName = pickBestNameCandidate(coName || "") || undefined;

    // employer + title
    extracted.employer =
      findLabeledValue(text, /(?:employer|company)\s*[:\-]\s*(.+)$/i) ||
      undefined;

    extracted.jobTitle =
      findLabeledValue(text, /(?:job\s*title|title|position)\s*[:\-]\s*(.+)$/i) ||
      undefined;

    extracted.coEmployer =
      findLabeledValue(text, /(?:co[-\s]?borrower|co[-\s]?applicant).*?(?:employer|company)\s*[:\-]\s*(.+)$/i) ||
      undefined;

    extracted.coJobTitle =
      findLabeledValue(text, /(?:co[-\s]?borrower|co[-\s]?applicant).*?(?:job\s*title|title|position)\s*[:\-]\s*(.+)$/i) ||
      undefined;

    // incomes
    const inc = extractIncomeNearKeywords(text, "borrower");
    if (typeof inc === "number") extracted.incomeAnnual = inc;

    const coInc = extractIncomeNearKeywords(text, "co");
    if (typeof coInc === "number") extracted.coIncomeAnnual = coInc;

    // credit + dti
    extracted.creditScore = extractCreditScore(text);
    extracted.dti = extractDTI(text);

    // red flags (very light)
    const redFlags: string[] = [];
    if (/\bdeclined\b/i.test(text)) redFlags.push("Document mentions 'declined' — verify context.");
    if (/\bcharge\s*off\b/i.test(text)) redFlags.push("Possible 'charge-off' language detected — verify on credit report.");
    if (/\bforeclosure\b/i.test(text)) redFlags.push("Possible foreclosure reference — verify timeline and eligibility.");

    const conditions = buildConditions(extracted);

    return NextResponse.json({
      ok: true,
      extractedChars: text.length,
      docName: body.docName || "",
      summary,
      preview,
      extracted,
      conditions,
      redFlags,
      mode: "rules_v1",
    });
  } catch (e: any) {
    return NextResponse.json({ ok: false, error: e?.message ?? "Unknown error" }, { status: 500 });
  }
}
